- [기초통계와 데이터 시각화(1) - 데이터 종류, pandas 시각화, 분산과 표준편차](#기초통계와-데이터-시각화1---데이터-종류-pandas-시각화-분산과-표준편차)
  - [숫자형 데이터](#숫자형-데이터)
    - [평균(mean)](#평균mean)
    - [중간값](#중간값)
    - [평균 vs 중간값](#평균-vs-중간값)
    - [중간값 계산하기](#중간값-계산하기)
    - [최솟값](#최솟값)
    - [최댓값](#최댓값)
  - [1사분위수와 3사분위수](#1사분위수와-3사분위수)
    - [1사분위(Q1), 2사분위수(Q2), 3사분위수(Q3)](#1사분위q1-2사분위수q2-3사분위수q3)
    - [1사분위수와 3사분위수 계산하기](#1사분위수와-3사분위수-계산하기)
  - [범주형 데이터](#범주형-데이터)
    - [최빈값 mode](#최빈값-mode)
  - [df.describe()](#dfdescribe)
  - [박스 플롯(Box plot)](#박스-플롯box-plot)
  - [히스토그램](#히스토그램)
  - [모집단과 표본](#모집단과-표본)
    - [KDE plot](#kde-plot)
  - [데이터 분포 모양](#데이터-분포-모양)
    - [왜도 skewness](#왜도-skewness)
    - [첨도](#첨도)
  - [분산과 표준편차](#분산과-표준편차)
    - [분산](#분산)
    - [표준편차](#표준편차)
    - [차이점](#차이점)
    - [분산, 표준편차 계산방법](#분산-표준편차-계산방법)
  - [누적값 계산하기](#누적값-계산하기)

---

# 기초통계와 데이터 시각화(1) - 데이터 종류, pandas 시각화, 분산과 표준편차

## 숫자형 데이터

### 평균(mean)

<br>

데이터 합계 / 총수

### 중간값

중간에 있는값

작은것 부터 큰것 까지 정렬해준뒤, 정확인 가운데에 있는 값.

만약 짝수라면

2개의 값을더해 2를 나누면 된다.

<br>

### 평균 vs 중간값

평균은 모든 값을 더해서 총 수만큼 나눈다.

다른 값에 비해 너무 크거나 작으면, 평균값은 영향을 받는다.

이처럼 올바른 평균값을 구할수없다.

이럴때 중간값을 쓰는게 더 적절하다.

<br>

### 중간값 계산하기

데이터의 개수가 짝수일때는 가운데의 두값의 합을 2로 나누어준면된다.

예를들어 중간에 각각 75와 80이 있다면, (75 + 80) / 2 = 77.5
중간값은 77.5가 된다.

<br>

### 최솟값

제일 작은값

<br>

### 최댓값

<br>

제일 큰값

## 1사분위수와 3사분위수

### 1사분위(Q1), 2사분위수(Q2), 3사분위수(Q3)

quratile의 앞문자를 따옴.

각각 25% 50% 75%의 값을 말함.

<br>

### 1사분위수와 3사분위수 계산하기

1사분위수는 25%에 해당하는 값이다. 따라서 데이터 개수에서 1을 뺀뒤, 여기에 0.25를 곱해주면된다.

예를들어 데이터가 총 8개라면, (8 - 1) x 0.25 = 1.75번 인덱스가 1사분위수가 된다.

1.75번 인덱스라면 굉장히 애매해보인다. 이럴때는 1번인덱스 값과 2번인덱스 사이에 위치하고 있다는 뜻이다.

만약 1번인덱스가 60, 2번인덱스가 74라면, 60 x (1 - 0.75) + 74 x 0.75를 계산하면된다.

1사분위수는 70.5가된다.

<br>

3사분위수도 똑같이 구하면된다. (8(총 데이터 개수) - 1) x 0.75 = 5.25이다. 5.25번 인덱스가 3사분위수가 된다. 5번 인덱스와 6번 인덱스 사이라는 뜻이다. 5번인덱스 값이 82, 6번이 92이라면, 82 x (1 - 0.25) + 92 x 0.25를 계산하면된다. 즉 3사분위수는 84.5가된다.

<br>

## 범주형 데이터

문자로 된 데이터, 숫자계산이 안됨, 평균 중간값 Q1 등등 구할수없음

몇가지 종류값이 있는지, 어떤 값이 가장 많이나오는지

<br>

### 최빈값 mode

제일 자주나오는 값

범주형 데이터는 값의 종류가 몇가지인지 살펴보기도 한다.

<br>

## df.describe()

데이터 컬럼별로 기본적인 통계 정보를 요약해서 볼 수 있다.

![image.png](../images/AI%20엔지니어%20기초%20지식/1.png)

mean은 평균값

std는 표준편차

min은 제일 작은값

max는 제일큰값

<br>

`include=’all’` 을 추가하면 범주형 데이터를 위한 통계정보가 나온다

unique 는 제일 적게 나온값

top 가장 많이나온값(최빈값)

freq 최빈값이 몇번 등장하는지

<br>

## 박스 플롯(Box plot)

![image.png](../images/AI%20엔지니어%20기초%20지식/2.png)

가운데 초록색 선이 50퍼 센트라는 뜻이다. 즉 중간값이다. 중간값이 60이 살짝넘어보인다. 상자의 아랫부분은 25%이고 윗지점은 3사분위점인 75%이다.

위아래의 동그라미들은 **이상점**이라고 한다. 정상범위 값 들을 넘어선 값들이다. 이런 값들은 보통 제외한다.

<br>

이상점을 정하는 기준은 무엇일까? 저 파란 상자가 IQR(interquartile Range)이라고 한다. 그리고 이박스에서 1.5IQR 떨어진 곳까지만 정상범위라고 한다. IQR를 벗어난 범위의 값들이 저런 동그라미들의 값들이다.

위아래의 꼭다리는 정상범위의 최댓값과 최솟값이다.

<br>

아래와 같은 코드를 치면 박스플롯을 만들수있다.

`DataFrame.plot(kind=’box’)`

Q1과 Q3을 구하는 방법

Q1 → `df[’english_score’].quantile(0.25)`

Q3 → `df[’english_score’].quantile(0.75)`

<br>

## 히스토그램

수치형데이터에서도 2개가 나누어진다.

개수같은 경우는 딱딱 떨어지지만 그렇지 않은경우도 있다.

예를들어 키나 몸무게는 딱딱 떨어지지 않는다.

<br>

숫자가 딱딱 떨어지는 데이터를 **이산형 데이터**라고 한다.

숫자가 딱딱 떨어지지 않는 데이터를 **연속형 데이터**라고 한다.

<br>

연속형 데이터를 보통 히스토그램으로 표현한다.

해당 범위에 속하는 사람 몇명 이런식으로 만드는 그래프이다.

예를들어 160cm~170cm 사이의 학생들 이런식으로 할때 쓴다.

<br>

이산형 데이터도 히스토그램을 쓰기도 한다.

코드는 아래와 같이 하면 히스토그램을 만들수있다.

`df[’height’].plot(kind='hist')`

![image.png](../images/AI%20엔지니어%20기초%20지식/3.png)

막대 개수가 따로 정하지 않으면 10개가된다. 따로 정하려면 bins에 넣어주면된다.

`df[’height’].plot(kind='hist', bins=15)`

<br>

## 모집단과 표본

모든 데이터를 모으기 위해서는 비용과 시간이 많이 든다.

따라서 전체 데이터중 일부만 조사해서 쓰기도 한다.

**원래 파악하고 싶었던 전체 집단을 모집단**이라고 한다.

**모집단에서 뽑아낸 일부를 표본(sample)**이라고한다.

<br>

통계도 세부 분야로 나뉜다.

기술 통계(Descriptive Statistics)

데이터 요약 및 핵심적인 특징을 파악하는 분야

<br>

추론 통계(Inferential Statistics)

모집단과 표본이 핵심적인 개념이 된다.

모집단을 어려운 상황에서 표본을 바탕으로 모집단이 어떨지 추론을 하는것이다.

<br>

### KDE plot

히스토그램을 쓰면 범위를 만들어서 연속형 데이터를 표현할수있다.

하지만 단순화된 표현을 해줄수밖에 없다.

<br>

연속형 데이터를 세밀하게 표현하기 위해서는 **확률 밀도 함수**를 알아야한다.

**각 구간이 전체에서 차지하는 비중을 말한다.**

아래는 확률 밀도 함수이다.

![image.png](../images/AI%20엔지니어%20기초%20지식/4.png)

하지만 확률 밀도 함수는 완벽하게 구할수없다. 히스토그램은 실제데이터를 바탕으로한다. 하지만 확률 밀도 함수은 모집단 전체를 표현한다는 비현실적인 가정이 들어가 있는것이다.

그래서 나름 해결책이 있다. 주어진 표본만 갖고 대략적을 추측해서 확률 밀도 함수를 비스무리하게 만드는것이다. 대표적으로 **KDE Plot(Kernel Density Estimation Plot)이 있다. 주어진 정보만 가지고 전체 데이터 분포에 대한 추정**을 해서 하나의 부드러운 곡선 모양을 그릴수있다.

<br>

코드 사용법

`df[’height’].plot(kind=’kde’)`

<br>

## 데이터 분포 모양

데이터는 대부분 비슷한 모양이 많다.

대부분 정규분포와 비슷하다.

**정규분포는 중간에 데이터가 많이 몰려있어서 엄청 크건나 작은 값들이 상대적으로 적은 형태이다.**

![image.png](../images/AI%20엔지니어%20기초%20지식/5.png)

정규분포와 다르게 한쪽으로 치우쳐진 경우가 있다.

오른쪽으로 긴꼬리를 가진 비대칭 적인 형태를 **Right-skewed** 또는 **Positively-skewed**라고도 부른다.

왼쪽으로 긴꼬리를 가진 형태는 **Left-skewed** 또는 **Negatively-skewed** 라고도 부른다.

![image.png](../images/AI%20엔지니어%20기초%20지식/6.png)

<br>

### 왜도 skewness

데이터가 기울어진 정도를 말한다.

위와 같은 오른쪽으로 긴꼬리를 가진 그래프는 왜도 > 0, 즉 왜도가 0보다큰 양수로 표현한다.

왼쪽으로 긴꼬리는 반대로 왜도 < 0, 음수로 표현한다.

왜도의 절대값이 클수록 비뚫어진 정도가 심해진다.

<br>

### 첨도

첨도가 높다는 것은 **가운데에 집중적으로 데이터가 심하게 몰려있고 양쪽으로 데이터가 거의 없는것을 말한다.**

![image.png](../images/AI%20엔지니어%20기초%20지식/7.png)

<br>

## 분산과 표준편차

### 분산

데이터가 평균에서 얼마나 떨어져 있는지를 나타내는 값.

<br>

### 표준편차

분산에 루트를 씌운값이다.

단위가 원래 데이터와 같아 직관적으로 해석하기 쉬움.

<br>

### 차이점

- **분산**은 제곱된 값이므로 단위가 원래 데이터의 단위와 다름.
- **표준편차**는 분산의 제곱근이므로 원래 데이터의 단위와 동일.

<br>

### 분산, 표준편차 계산방법

모든 데이터 값을 더한후 평균에서 각 요소별로 빼준다.

예를들어) 10 20 30 40 50이 있다면, 10 + 20 + 30 + 40 + 50 / 5 = 30

각각의 요소에 평균을 빼준다. 30 -10, 30 - 20, 30 -30, 30 - 40, 30-50.

(20,10,0,-10,-20)각 값의 제곱을해준다.

(400, 100,0,100,400) 제곱을 해주는이유는 **양수로 통일시키고 편차가 큰값들을 더 부각시키기 위해서이다.**

이후 각 값을 더한후 총개수로 나누어주면된다. 400 + 100 + 0 + 100 + 400 / 5 = 200. 분산 값은 200이 된다.

<br>

표준편차는 분산의 값에 루트를 씌어주면된다.

아까 제곱을 해줬으므로 다시 루트를 씌어주는것이다.

따라서 분산이 200인 표준편차는 14.14가 된다.

<br>

분산을 구하는 코드

`df[’height’].var()`

<br>

표준편차을 구하는 코드

`df[’height’].std()`

<br>

## 누적값 계산하기

각 컬럼 데이터를 누적한 값이 필요할때가 있다.

예를들어 매달 방문객수 데이터가 있고 누적 방문객수를 더할때 필요하기도 하다.

<br>

누적해서 더하는 코드

`df[’visitor’].cumsum()`

<br>

누적해서 곱하는 코드

`df[’multiple’].cumprod()`
